import numpy as np

from stem_measurements.dead_pixels_map import BadPixelsInput

class StemMeasurementsError(Exception):
    pass

# ellipses -----------------------------------------------------------------------------------------------------------
def ellipse(image: np.ndarray, threshold: int) -> tuple[float, float, float, float, float]: ...
def ellipse_batch(images: np.ndarray, threshold: int, thread_count: int = 1) -> np.ndarray: ...

class EllipseBatchCompressed:
    def __init__(self, shape: tuple[int, ...], dtype: np.dtype, thread_count: int = 1) -> None: ...
    def __call__(self, data: np.ndarray, lengths: list[int], threshold: int) -> np.ndarray: ...

# center of mass -----------------------------------------------------------------------------------------------------
def center_of_mass_core(images: np.ndarray) -> np.ndarray: ...

# correlation coefficient --------------------------------------------------------------------------------------------
def correl_coeff(
    img_0: np.ndarray,
    img_1: np.ndarray,
    shift: tuple,
    rectangle_0: tuple[int, int, int, int] | None = None,
    rectangle_1: tuple[int, int, int, int] | None = None,
) -> float:
    """Get pearson correlation coefficient between two images.

    Args:
        img_0 (np.ndarray): The refernce image.
        img_1 (np.ndarray): The shifted image.
        shift (tuple): The shift between the images.
        rectangle_0 (tuple[int, int, int, int] | None): The ROI rectangle for the first image.
        rectangle_1 (tuple[int, int, int, int] | None): The ROI rectangle for the second image.

    Returns:
        float: The correlation coefficient between the images.
    """
    pass

# virtual detectors --------------------------------------------------------------------------------------------------
def set_mask_det(mask: np.ndarray) -> None: ...
def reset_mask_det() -> None: ...
def virtual_detector_core(images: np.ndarray, thread_count: int = 1) -> np.ndarray: ...

class VirtualDetectorCore:
    def __init__(self, thread_count: int = 1) -> None: ...
    def __call__(self, images: np.ndarray) -> np.ndarray: ...

class VirtualDetectorCompressedCore:
    def __init__(self, shape: tuple[int, ...], dtype: np.dtype, thread_count: int = 1) -> None: ...
    def __call__(self, data: np.ndarray, lengths: list[int]) -> np.ndarray: ...

# class ThreadSum:
#     def __init__(self): ...
#     def put(self, image: np.ndarray) -> None: ...
#     def get(self) -> np.ndarray: ...
#     def close(self) -> None: ...

# bitshuffle ---------------------------------------------------------------------------------------------------------
def bitshuffle_compress(image: np.ndarray, block_size: int = 0) -> np.ndarray: ...
def bitshuffle_decompress(data: np.ndarray, output: np.ndarray) -> np.ndarray: ...
def bitshuffle_decompress_batch(
    data: np.ndarray, lengths: list[int], output: np.ndarray, thread_count: int = ...
) -> np.ndarray: ...
def bitshuffle_using_avx2() -> bool: ...
def bitshuffle_using_sse2() -> bool: ...
def set_bad_pixels_mask(dead_pixel_map: BadPixelsInput, shape: tuple[int, int]) -> None: ...
def reset_bad_pixels_mask() -> None: ...

# image cache file ---------------------------------------------------------------------------------------------------
class ImagesFileCore:
    def __init__(
        self,
        path: str,
        create_new: bool,
        scan_shape: tuple[int, ...] | None = ...,
        images_shape: tuple[int, int] | None = ...,
        dtype: np.dtype | None = ...,
        decompress_threads: int = ...,
        buffers_size: int = ...,
        buffers_count: int = ...,
    ) -> None: ...
    def get_single(self, position: tuple[int, ...], output: None | np.ndarray = None) -> np.ndarray: ...
    def get_multiple(self, positions: tuple[np.ndarray], output: np.ndarray) -> None: ...
    def write_chunks(self, data: np.ndarray, lengths: list[int]) -> None: ...
    def read_chunk(self, position: tuple[int, ...], output: None | np.ndarray = None) -> tuple[np.ndarray, int]: ...
    def get_chunk_size(self, position: tuple[int, ...]) -> int: ...
    def clear_buffers(self) -> None: ...
    def close(self) -> None: ...
    def is_open(self) -> bool: ...

# hdf5 items ---------------------------------------------------------------------------------------------------------
def is_hdf5_enabled() -> bool: ...
def hdf5_version() -> str: ...

class HDF5RW:
    def __init__(
        self,
        path: str,
        dataset_name: str,
        mode: str,
        decompress_threads: int = ...,
        buffers_size: int = ...,
        buffers_count: int = ...,
    ) -> None: ...
    def get_single(self, position: tuple[int, ...], output: None | np.ndarray = None) -> np.ndarray: ...
    def get_multiple(self, positions: tuple[np.ndarray], output: np.ndarray) -> None: ...
    def write_chunks(self, data: np.ndarray, lengths: list[int]) -> None: ...
    def read_chunk(self, position: tuple[int, ...], output: None | np.ndarray = None) -> tuple[np.ndarray, int]: ...
    def get_chunk_size(self, position: tuple[int, ...]) -> int: ...
    def clear_buffers(self) -> None: ...
    def close(self) -> None: ...
    def is_open(self) -> bool: ...

    # def write_chunk(self, position: tuple[int, ...], data: np.ndarray) -> None: ...
